#lang scheme
(define (make-interval a b)
  (if (< a b)
      (cons a b)
      (cons b a)))
(define (lower-bound c)
  (car c))
(define (upper-bound c)
  (cdr c))

(define (mul-interval x y)
  (let ((pozition-zero (lambda (i)
                         (cond ((> (lower-bound i) 0) 1)
                               ((< (upper-bound i) 0) -1)
                               (else 0))))
        (x-pz (pozition-zero x))
        (y-pz (pozition-zero y))
        (x-lower (lower-bound x))
        (x-upper (upper-bound x))
        (y-lower (lower-bound y))
        (y-upper (upper-bound y)))
    (cond ((< x-pz)
           (cond ((< y-pz)
                  (make-interval (* x-upper y-upper)
                                 (* x-lower y-lower)))
                 ((> y-pz)
                  (make-interval (* x-lower y-upper)
                                 (* x-upper y-lower)))
                 (else
                  (make-interval (* x-lower y-upper)
                                 (* x-lower y-lower)))))
          ((> x-pz)
           (cond ((< y-pz)
                  (make-interval (* x-upper y-lower)
                                 (* x-lower y-upper)))
                 ((> y-pz)
                  (make-interval (* x-lower y-lower)
                                 (* x-upper y-upper)))
                 (else
                  (make-interval (* x-upper y-lower)
                                 (* x-upper y-upper)))))
          (else
           (cond ((< y-pz)
                  (make-interval (* x-upper y-lower)
                                 (* x-lower y-lower)))
                 ((> y-pz)
                  (make-interval (* x-lower y-upper)
                                 (* x-upper y-upper)))
                 (else
                  (make-interval (min (* x-lower y-upper)         ;; !four multiplies
                                      (* x-upper y-lower))
                                 (max (* x-lower y-lower)
                                      (* x-upper y-upper)))))))))